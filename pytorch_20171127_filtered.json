[{
  "id": 65600975,
  "name": "pytorch",
  "full_name": "pytorch/pytorch",
  "html_url": "https://github.com/pytorch/pytorch",
  "description": "Tensors and Dynamic neural networks in Python  with strong GPU acceleration",
  "created_at": "2016-08-13T05:26:41Z",
  "updated_at": "2017-11-26T14:48:46Z",
  "stargazers_count": 9505,
  "watchers_count": 9505,
  "language": "Python",
  "forks_count": 2015,
  "readme": "b'<p align=\"center\"><img width=\"40%\" src=\"docs/source/_static/img/pytorch-logo-dark.png\" /></p>\\n\\n--------------------------------------------------------------------------------\\n\\nPyTorch is a Python package that provides two high-level features:\\n- Tensor computation (like NumPy) with strong GPU acceleration\\n- Deep neural networks built on a tape-based autograd system\\n\\nYou can reuse your favorite Python packages such as NumPy, SciPy and Cython to extend PyTorch when needed.\\n\\nWe are in an early-release beta. Expect some adventures and rough edges.\\n\\n- [More about PyTorch](#more-about-pytorch)\\n- [Installation](#installation)\\n  - [Binaries](#binaries)\\n  - [From Source](#from-source)\\n  - [Docker Image](#docker-image)\\n  - [Previous Versions](#previous-versions)\\n- [Getting Started](#getting-started)\\n- [Communication](#communication)\\n- [Releases and Contributing](#releases-and-contributing)\\n- [The Team](#the-team)\\n\\n| System | 2.7 | 3.5 |\\n| --- | --- | --- |\\n| Linux CPU | [![Build Status](https://travis-ci.org/pytorch/pytorch.svg?branch=master)](https://travis-ci.org/pytorch/pytorch) | [![Build Status](https://travis-ci.org/pytorch/pytorch.svg?branch=master)](https://travis-ci.org/pytorch/pytorch) |\\n| Linux GPU | [![Build Status](http://build.pytorch.org:8080/buildStatus/icon?job=pytorch-master-py2-linux)](https://build.pytorch.org/job/pytorch-master-py2-linux) | [![Build Status](http://build.pytorch.org:8080/buildStatus/icon?job=pytorch-master-py3-linux)](https://build.pytorch.org/job/pytorch-master-py3-linux) |\\n| macOS CPU | [![Build Status](http://build.pytorch.org:8080/buildStatus/icon?job=pytorch-master-py2-osx-cpu)](https://build.pytorch.org/job/pytorch-master-py2-osx-cpu) | [![Build Status](http://build.pytorch.org:8080/buildStatus/icon?job=pytorch-master-py3-osx-cpu)](https://build.pytorch.org/job/pytorch-master-py3-osx-cpu) |\\n\\n\\n## More about PyTorch\\n\\nAt a granular level, PyTorch is a library that consists of the following components:\\n\\n<table>\\n<tr>\\n    <td><b> torch </b></td>\\n    <td> a Tensor library like NumPy, with strong GPU support </td>\\n</tr>\\n<tr>\\n    <td><b> torch.autograd </b></td>\\n    <td> a tape-based automatic differentiation library that supports all differentiable Tensor operations in torch </td>\\n</tr>\\n<tr>\\n    <td><b> torch.nn </b></td>\\n    <td> a neural networks library deeply integrated with autograd designed for maximum flexibility </td>\\n</tr>\\n<tr>\\n    <td><b> torch.multiprocessing  </b></td>\\n    <td> Python multiprocessing, but with magical memory sharing of torch Tensors across processes. Useful for data loading and Hogwild training. </td>\\n</tr>\\n<tr>\\n    <td><b> torch.utils </b></td>\\n    <td> DataLoader, Trainer and other utility functions for convenience </td>\\n</tr>\\n<tr>\\n    <td><b> torch.legacy(.nn/.optim) </b></td>\\n    <td> legacy code that has been ported over from torch for backward compatibility reasons </td>\\n</tr>\\n</table>\\n\\nUsually one uses PyTorch either as:\\n\\n- a replacement for NumPy to use the power of GPUs.\\n- a deep learning research platform that provides maximum flexibility and speed\\n\\nElaborating further:\\n\\n### A GPU-Ready Tensor Library\\n\\nIf you use NumPy, then you have used Tensors (a.k.a ndarray).\\n\\n<p align=center><img width=\"30%\" src=\"docs/source/_static/img/tensor_illustration.png\" /></p>\\n\\nPyTorch provides Tensors that can live either on the CPU or the GPU, and accelerate\\ncompute by a huge amount.\\n\\nWe provide a wide variety of tensor routines to accelerate and fit your scientific computation needs\\nsuch as slicing, indexing, math operations, linear algebra, reductions.\\nAnd they are fast!\\n\\n### Dynamic Neural Networks: Tape-Based Autograd\\n\\nPyTorch has a unique way of building neural networks: using and replaying a tape recorder.\\n\\nMost frameworks such as TensorFlow, Theano, Caffe and CNTK have a static view of the world.\\nOne has to build a neural network, and reuse the same structure again and again.\\nChanging the way the network behaves means that one has to start from scratch.\\n\\nWith PyTorch, we use a technique called reverse-mode auto-differentiation, which allows you to\\nchange the way your network behaves arbitrarily with zero lag or overhead. Our inspiration comes\\nfrom several research papers on this topic, as well as current and past work such as\\n[torch-autograd](https://github.com/twitter/torch-autograd),\\n[autograd](https://github.com/HIPS/autograd),\\n[Chainer](http://chainer.org), etc.\\n\\nWhile this technique is not unique to PyTorch, it\\'s one of the fastest implementations of it to date.\\nYou get the best of speed and flexibility for your crazy research.\\n\\n<p align=center><img width=\"80%\" src=\"docs/source/_static/img/dynamic_graph.gif\" /></p>\\n\\n### Python First\\n\\nPyTorch is not a Python binding into a monolithic C++ framework.\\nIt is built to be deeply integrated into Python.\\nYou can use it naturally like you would use NumPy / SciPy / scikit-learn etc.\\nYou can write your new neural network layers in Python itself, using your favorite libraries\\nand use packages such as Cython and Numba.\\nOur goal is to not reinvent the wheel where appropriate.\\n\\n### Imperative Experiences\\n\\nPyTorch is designed to be intuitive, linear in thought and easy to use.\\nWhen you execute a line of code, it gets executed. There isn\\'t an asynchronous view of the world.\\nWhen you drop into a debugger, or receive error messages and stack traces, understanding them is straightforward.\\nThe stack trace points to exactly where your code was defined.\\nWe hope you never spend hours debugging your code because of bad stack traces or asynchronous and opaque execution engines.\\n\\n### Fast and Lean\\n\\nPyTorch has minimal framework overhead. We integrate acceleration libraries\\nsuch as Intel MKL and NVIDIA (cuDNN, NCCL) to maximize speed.\\nAt the core, its CPU and GPU Tensor and neural network backends\\n(TH, THC, THNN, THCUNN) are written as independent libraries with a C99 API.\\nThey are mature and have been tested for years.\\n\\nHence, PyTorch is quite fast \\xe2\\x80\\x93 whether you run small or large neural networks.\\n\\nThe memory usage in PyTorch is extremely efficient compared to Torch or some of the alternatives.\\nWe\\'ve written custom memory allocators for the GPU to make sure that\\nyour deep learning models are maximally memory efficient.\\nThis enables you to train bigger deep learning models than before.\\n\\n### Extensions without Pain\\n\\nWriting new neural network modules, or interfacing with PyTorch\\'s Tensor API was designed to be straightforward\\nand with minimal abstractions.\\n\\nYou can write new neural network layers in Python using the torch API\\n[or your favorite NumPy-based libraries such as SciPy](http://pytorch.org/tutorials/advanced/numpy_extensions_tutorial.html).\\n\\nIf you want to write your layers in C/C++, we provide an extension API based on\\n[cffi](http://cffi.readthedocs.io/en/latest/) that is efficient and with minimal boilerplate.\\nThere is no wrapper code that needs to be written. You can see [a tutorial here](http://pytorch.org/tutorials/advanced/c_extension.html) and [an example here](https://github.com/pytorch/extension-ffi).\\n\\n\\n## Installation\\n\\n### Binaries\\nCommands to install from binaries via Conda or pip wheels are on our website:\\n\\n[http://pytorch.org](http://pytorch.org)\\n\\n### From Source\\n\\nIf you are installing from source, we highly recommend installing an [Anaconda](https://www.continuum.io/downloads) environment.\\nYou will get a high-quality BLAS library (MKL) and you get a controlled compiler version regardless of your Linux distro.\\n\\nOnce you have [Anaconda](https://www.continuum.io/downloads) installed, here are the instructions.\\n\\nIf you want to compile with CUDA support, install\\n- [NVIDIA CUDA](https://developer.nvidia.com/cuda-downloads) 7.5 or above\\n- [NVIDIA cuDNN](https://developer.nvidia.com/cudnn) v6.x or above\\n\\nIf you want to disable CUDA support, export environment variable `NO_CUDA=1`.\\n\\n#### Install optional dependencies\\n\\nOn Linux\\n```bash\\nexport CMAKE_PREFIX_PATH=\"$(dirname $(which conda))/../\" # [anaconda root directory]\\n\\n# Install basic dependencies\\nconda install numpy pyyaml mkl setuptools cmake cffi\\n\\n# Add LAPACK support for the GPU\\nconda install -c soumith magma-cuda80 # or magma-cuda75 if CUDA 7.5\\n```\\n\\nOn macOS\\n```bash\\nexport CMAKE_PREFIX_PATH=[anaconda root directory]\\nconda install numpy pyyaml setuptools cmake cffi\\n```\\n#### Get the PyTorch source\\n```bash\\ngit clone --recursive https://github.com/pytorch/pytorch\\n```\\n\\n#### Install PyTorch\\nOn Linux\\n```bash\\npython setup.py install\\n```\\n\\nOn macOS\\n```bash\\nMACOSX_DEPLOYMENT_TARGET=10.9 CC=clang CXX=clang++ python setup.py install\\n```\\n\\n### Docker image\\n\\nDockerfile is supplied to build images with cuda support and cudnn v6. Build as usual\\n```\\ndocker build -t pytorch .\\n```\\n\\nDockerfile to build with cuda 9 and cudnn v7 (with Volta support) is in tools/docker, the build command is\\n\\n```\\ndocker build -t pytorch_cuda9 -f tools/docker/Dockerfile9 .\\n```\\nAlternatively, if you want to use a runtime image, you can use the pre-built one from Docker Hub and run with nvidia-docker:\\n```\\nnvidia-docker run --rm -ti --ipc=host pytorch/pytorch:latest\\n```\\nPlease note that PyTorch uses shared memory to share data between processes, so if torch multiprocessing is used (e.g.\\nfor multithreaded data loaders) the default shared memory segment size that container runs with is not enough, and you\\nshould increase shared memory size either with `--ipc=host` or `--shm-size` command line options to `nvidia-docker run`.\\n\\n### Previous Versions\\n\\nInstallation instructions and binaries for previous PyTorch versions may be found\\non [our website](http://pytorch.org/previous-versions/).\\n\\n\\n## Getting Started\\n\\nThree pointers to get you started:\\n- [Tutorials: get you started with understanding and using PyTorch](http://pytorch.org/tutorials/)\\n- [Examples: easy to understand pytorch code across all domains](https://github.com/pytorch/examples)\\n- [The API Reference](http://pytorch.org/docs/)\\n\\n## Communication\\n* forums: discuss implementations, research, etc. http://discuss.pytorch.org\\n* GitHub issues: bug reports, feature requests, install issues, RFCs, thoughts, etc.\\n* Slack: general chat, online discussions, collaboration etc. https://pytorch.slack.com/ . Our slack channel is invite-only to promote a healthy balance between power-users and beginners. If you need a slack invite, ping us at soumith@pytorch.org\\n* newsletter: no-noise, one-way email newsletter with important announcements about pytorch. You can sign-up here: http://eepurl.com/cbG0rv\\n\\n## Releases and Contributing\\n\\nPyTorch has a 90 day release cycle (major releases).\\nIt\\'s current state is Beta, we expect no obvious bugs. Please let us know if you encounter a bug by [filing an issue](https://github.com/pytorch/pytorch/issues).\\n\\nWe appreciate all contributions. If you are planning to contribute back bug-fixes, please do so without any further discussion.\\n\\nIf you plan to contribute new features, utility functions or extensions to the core, please first open an issue and discuss the feature with us.\\nSending a PR without discussion might end up resulting in a rejected PR, because we might be taking the core in a different direction than you might be aware of.\\n\\n## The Team\\n\\nPyTorch is a community driven project with several skillful engineers and researchers contributing to it.\\n\\nPyTorch is currently maintained by [Adam Paszke](https://apaszke.github.io/), [Sam Gross](https://github.com/colesbury), [Soumith Chintala](http://soumith.ch) and [Gregory Chanan](https://github.com/gchanan) with major contributions coming from 10s of talented individuals in various forms and means.\\nA non-exhaustive but growing list needs to mention: Trevor Killeen, Sasank Chilamkurthy, Sergey Zagoruyko, Adam Lerer, Francisco Massa, Alykhan Tejani, Luca Antiga, Alban Desmaison, Andreas Kopf, James Bradbury, Zeming Lin, Yuandong Tian, Guillaume Lample, Marat Dukhan, Natalia Gimelshein, Christian Sarofeen, Martin Raison, Edward Yang, Zachary Devito.\\n\\nNote: this project is unrelated to [hughperkins/pytorch](https://github.com/hughperkins/pytorch) with the same name. Hugh is a valuable contributor in the Torch community and has helped with many things Torch and PyTorch.\\n'",
  "topics": [
    "neural-network",
    "autograd",
    "gpu",
    "numpy",
    "deep-learning",
    "tensor",
    "python"
  ]
},{
  "id": 41579370,
  "name": "pytorch",
  "full_name": "hughperkins/pytorch",
  "html_url": "https://github.com/hughperkins/pytorch",
  "description": "Python wrappers for torch and lua",
  "created_at": "2015-08-29T03:31:50Z",
  "updated_at": "2017-11-21T01:19:28Z",
  "stargazers_count": 361,
  "watchers_count": 361,
  "language": "Python",
  "forks_count": 46,
  "readme": "b'# pytorch\\nWrappers to use torch and lua from python\\n\\n# What is pytorch?\\n\\n- create torch tensors, call operations on them\\n- instantiate `nn` network modules, train them, make predictions\\n- create your own lua class, call methods on that\\n\\n## Create torch tensors\\n\\n```\\nimport PyTorch\\na = PyTorch.FloatTensor(2,3).uniform()\\na += 3\\nprint(\\'a\\', a)\\nprint(\\'a.sum()\\', a.sum())\\n```\\n\\n## Instantiate nn network modules\\n\\n```\\nimport PyTorch\\nfrom PyTorchAug import nn\\n\\nnet = nn.Sequential()\\nnet.add(nn.SpatialConvolutionMM(1, 16, 5, 5, 1, 1, 2, 2))\\nnet.add(nn.ReLU())\\nnet.add(nn.SpatialMaxPooling(3, 3, 3, 3))\\n\\nnet.add(nn.SpatialConvolutionMM(16, 32, 3, 3, 1, 1, 1, 1))\\nnet.add(nn.ReLU())\\nnet.add(nn.SpatialMaxPooling(2, 2, 2, 2))\\n\\nnet.add(nn.Reshape(32 * 4 * 4))\\nnet.add(nn.Linear(32 * 4 * 4, 150))\\nnet.add(nn.Tanh())\\nnet.add(nn.Linear(150, 10))\\nnet.add(nn.LogSoftMax())\\nnet.float()\\n\\ncrit = nn.ClassNLLCriterion()\\ncrit.float()\\n\\nnet.zeroGradParameters()\\ninput = PyTorch.FloatTensor(5, 1, 28, 28).uniform()\\nlabels = PyTorch.ByteTensor(5).geometric(0.9).icmin(10)\\noutput = net.forward(input)\\nloss = crit.forward(output, labels)\\ngradOutput = crit.backward(output, labels)\\ngradInput = net.backward(input, gradOutput)\\nnet.updateParameters(0.02)\\n```\\n\\n# Write your own lua class, call methods on it\\n\\nExample lua class:\\n```\\nrequire \\'torch\\'\\nrequire \\'nn\\'\\n\\nlocal TorchModel = torch.class(\\'TorchModel\\')\\n\\nfunction TorchModel:__init(backend, imageSize, numClasses)\\n  self:buildModel(backend, imageSize, numClasses)\\n  self.imageSize = imageSize\\n  self.numClasses = numClasses\\n  self.backend = backend\\nend\\n\\nfunction TorchModel:buildModel(backend, imageSize, numClasses)\\n  self.net = nn.Sequential()\\n  local net = self.net\\n\\n  net:add(nn.SpatialConvolutionMM(1, 16, 5, 5, 1, 1, 2, 2))\\n  net:add(nn.ReLU())\\n  net:add(nn.SpatialMaxPooling(3, 3, 3, 3))\\n  net:add(nn.SpatialConvolutionMM(16, 32, 3, 3, 1, 1, 1, 1))\\n  net:add(nn.ReLU())\\n  net:add(nn.SpatialMaxPooling(2, 2, 2, 2))\\n  net:add(nn.Reshape(32 * 4 * 4))\\n  net:add(nn.Linear(32 * 4 * 4, 150))\\n  net:add(nn.Tanh())\\n  net:add(nn.Linear(150, numClasses))\\n  net:add(nn.LogSoftMax())\\n\\n  self.crit = nn.ClassNLLCriterion()\\n\\n  self.net:float()\\n  self.crit:float()\\nend\\n\\nfunction TorchModel:trainBatch(learningRate, input, labels)\\n  self.net:zeroGradParameters()\\n\\n  local output = self.net:forward(input)\\n  local loss = self.crit:forward(output, labels)\\n  local gradOutput = self.crit:backward(output, labels)\\n  self.net:backward(input, gradOutput)\\n  self.net:updateParameters(learningRate)\\n\\n  local _, prediction = output:max(2)\\n  local numRight = labels:int():eq(prediction:int()):sum()\\n  return {loss=loss, numRight=numRight}  -- you can return a table, it will become a python dictionary\\nend\\n\\nfunction TorchModel:predict(input)\\n  local output = self.net:forward(input)\\n  local _, prediction = output:max(2)\\n  return prediction:byte()\\nend\\n```\\n\\nPython script that calls this.  Assume the lua class is stored in file \"torch_model.lua\"\\n```\\nimport PyTorch\\nimport PyTorchHelpers\\nimport numpy as np\\nfrom mnist import MNIST\\n\\nbatchSize = 32\\nnumEpochs = 2\\nlearningRate = 0.02\\n\\nTorchModel = PyTorchHelpers.load_lua_class(\\'torch_model.lua\\', \\'TorchModel\\')\\ntorchModel = TorchModel(backend, 28, 10)\\n\\nmndata = MNIST(\\'../../data/mnist\\')\\nimagesList, labelsList = mndata.load_training()\\nlabels = np.array(labelsList, dtype=np.uint8)\\nimages = np.array(imagesList, dtype=np.float32)\\nlabels += 1  # since torch/lua labels are 1-based\\nN = labels.shape[0]\\n\\nnumBatches = N // batchSize\\nfor epoch in range(numEpochs):\\n  epochLoss = 0\\n  epochNumRight = 0\\n  for b in range(numBatches):\\n    res = torchModel.trainBatch(\\n      learningRate,\\n      images[b * batchSize:(b+1) * batchSize],\\n      labels[b * batchSize:(b+1) * batchSize])\\n    numRight = res[\\'numRight\\']\\n    epochNumRight += numRight\\n  print(\\'epoch \\' + str(epoch) + \\' accuracy: \\' + str(epochNumRight * 100.0 / N) + \\'%\\')\\n```\\n\\nIt\\'s easy to modify the lua script to use CUDA, or OpenCL.\\n\\n# Installation\\n\\n## Pre-requisites\\n\\n* Have installed torch, following instructions at [https://github.com/torch/distro](https://github.com/torch/distro)\\n* Have installed \\'nn\\' torch module:\\n```\\nluarocks install nn\\n```\\n* Have installed python (tested with 2.7 and 3.4)\\n* lua51 headers should be installed, ie something like `sudo apt-get install lua5.1 liblua5.1-dev`\\nRun:\\n```\\npip install -r requirements.txt\\n```\\n* To be able to run tests, also do:\\n```\\npip install -r test/requirements.txt\\n```\\n\\n## Procedure\\n\\nRun:\\n```\\ngit clone https://github.com/hughperkins/pytorch.git\\ncd pytorch\\nsource ~/torch/install/bin/torch-activate\\n./build.sh\\n```\\n\\n# Unit-tests\\n\\nRun:\\n```\\nsource ~/torch/install/bin/torch-activate\\ncd pytorch\\n./run_tests.sh\\n```\\n\\n# Python 2 vs Python 3?\\n\\n- pytorch is developed and maintained on python 3\\n- you should be able to use it with python 2, but there might be the occasional oversight.  Please log an issue\\nfor any python 2 incompatibilities you notice\\n\\n# Maintainer guidelines\\n\\n[Maintainer guidelines](doc/Maintainer_guidelines.md)\\n\\n# Versioning\\n\\n[semantic versioning](http://semver.org/)\\n\\n# Related projects\\n\\nExamples of training models/networks using pytorch:\\n* [pytorch-residual-networks](https://github.com/hughperkins/pytorch-residual-networks) port of Michael Wilber\\'s [torch-residual-networks](https://github.com/gcr/torch-residual-networks), to handle data loading and preprocessing from Python, via pytorch\\n* [cifar.pytorch](https://github.com/hughperkins/cifar.pytorch) pytorch implementation of Sergey\\'s [cifar.torch](https://github.com/szagoruyko/cifar.torch)\\n\\nAddons, for using cuda tensors and opencl tensors directly from python (no need for this to train networks.  could be useful if you want to manipulate cuda tensor\\ndirectly from python)\\n* [pycltorch](https://github.com/hughperkins/pycltorch) python wrappers for [cltorch](https://github.com/hughperkins/cltorch) and [clnn](https://github.com/hughperkins/clnn)\\n* [pycudatorch](https://github.com/hughperkins/pycudatorch) python wrappers for [cutorch](https://github.com/torch/cutorch) and [cunn](https://github.com/torch/cunn)\\n\\n# Support?\\n\\nPlease note that currently, right now, I\\'m focused 100.000% on [cuda-on-cl](https://github.com/hughperkins/cuda-on-cl), so please be patient during this period\\n\\n# Recent news\\n\\n12 September:\\n* Yannick Hold-Geoffroy added conversion of lists and tuples to Lua tables\\n\\n8 September:\\n* added `PyTorchAug.save(filename, object)` and `PyTorchAug.load(filename)`, to save/load Torch `.t7` files\\n\\n26 August:\\n* if not deploying to a virtual environment, will install with `--user`, into home directory\\n\\n14 April:\\n* stack trace should be a bit more useful now :-)\\n\\n17 March:\\n* ctrl-c works now (tested on linux)\\n\\n16 March:\\n* uses luajit on linux now (mac os x continues to use lua)\\n\\n6 March:\\n* all classes should be usable from `nn` now, without needing to explicitly register inside `pytorch`\\n  * you need to upgrade to `v3.0.0` to enable this, which is a breaking change, since the `nn` classes are now in `PyTorchAug.nn`, instead of directly\\nin `PyTorchAug`\\n\\n5 March:\\n* added `PyTorchHelpers.load_lua_class(lua_filename, lua_classname)` to easily import a lua class from a lua file\\n* can pass parameters to lua class constructors, from python\\n* can pass tables to lua functions, from python (pass in as python dictionaries, become lua tables)\\n* can return tables from lua functions, to python (returned as python dictionaries)\\n\\n2 March:\\n* removed requirements on Cython, Jinja2 for installation\\n\\n28th Februrary:\\n* builds ok on Mac OS X now :-)  See https://travis-ci.org/hughperkins/pytorch/builds/112292866\\n\\n26th February:\\n* modified `/` to be the div operation for float and double tensors, and `//` for int-type tensors, such as\\nbyte, long, int\\n* since the div change is incompatible with 1.0.0 div operators, jumping radically from `1.0.0` to `2.0.0-SNAPSHOT` ...\\n* added dependency on `numpy`\\n* added `.asNumpyTensor()` to convert a torch tensor to a numpy tensor\\n\\n24th February:\\n* added support for passing strings to methods\\n* added `require`\\n* created prototype for importing your own classes, and calling methods on those\\n* works with Python 3 now :-)\\n\\n[Older changes](doc/oldchanges.md)\\n'",
  "topics": []
}]